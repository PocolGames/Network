let quizData = [
    {
        question: "1. 최초의 멀티 코어 CPU는 언제 어느 회사에서 개발되었는가?",
        options: [
            "2000년 Intel에서 개발된 2개 코어 Pentium 칩",
            "2001년 IBM에서 개발된 2개 코어 PowerPC 칩",
            "1999년 AMD에서 개발된 2개 코어 Athlon 칩",
            "2002년 Motorola에서 개발된 2개 코어 68000 칩"
        ],
        answer: 2
    },
    {
        question: "2. 멀티코어 시스템에서 컨텍스트 스위칭 후 오버헤드 문제는 무엇인가?",
        options: [
            "메모리 사용량이 급격히 증가하는 문제",
            "전력 소비가 증가하는 문제",
            "이전에 실행된 적이 없는 코어에 스레드가 배치될 때 캐시 미스로 인한 성능 저하",
            "스레드 간 통신 비용이 증가하는 문제"
        ],
        answer: 3
    },
    {
        question: "3. 멀티코어 시스템에서 코어별 부하 불균형 문제가 발생하는 이유는?",
        options: [
            "스레드를 무작위로 코어에 할당하기 때문",
            "코어마다 성능이 다르기 때문",
            "메모리 대역폭이 제한되어 있기 때문",
            "운영체제 스케줄러가 비효율적이기 때문"
        ],
        answer: 1
    },
    {
        question: "4. CPU 친화성(CPU affinity)이란 무엇인가?",
        options: [
            "스레드가 특정 CPU 명령어 세트를 선호하는 것",
            "스레드를 동일한 코어에서만 실행하도록 스케줄링하는 것",
            "CPU가 특정 스레드를 우선 처리하는 것",
            "멀티코어 간의 동기화 메커니즘"
        ],
        answer: 2
    },
    {
        question: "5. CPU 친화성의 다른 명칭이 아닌 것은?",
        options: [
            "코어 친화성(Core affinity)",
            "CPU 피닝(Pinning)",
            "캐시 친화성(Cache affinity)",
            "Load Balancing"
        ],
        answer: 4
    },
    {
        question: "6. 멀티코어 시스템에서 컨텍스트 스위칭 후 오버헤드 문제를 해결하는 방법이 아닌 것은?",
        options: [
            "CPU 친화성 적용",
            "코어 당 스레드 큐 사용",
            "더 빠른 메모리 사용",
            "더 큰 캐시 메모리 사용"
        ],
        answer: 3
    },
    {
        question: "7. 푸시 마이그레이션(Push Migration) 기법의 정의는?",
        options: [
            "빈 코어가 다른 코어의 스레드를 가져와 실행시키는 기법",
            "감시 스레드가 짧거나 빈 큐를 가진 코어에 다른 큐의 스레드를 옮겨놓는 기법",
            "스레드가 자발적으로 다른 코어로 이동하는 기법",
            "우선순위에 따라 스레드를 강제로 이동시키는 기법"
        ],
        answer: 2
    },
    {
        question: "8. 풀 마이그레이션(Pull Migration) 기법의 정의는?",
        options: [
            "감시 스레드가 부하가 적은 코어에 스레드를 배치하는 기법",
            "코어가 처리할 스레드가 없게 되면 다른 코어의 스레드 큐에서 자신의 큐로 가져와 실행시키는 기법",
            "스레드를 원래 실행되던 코어로 되돌리는 기법",
            "시스템이 자동으로 부하를 균등하게 분산시키는 기법"
        ],
        answer: 2
    },
    {
        question: "9. 멀티코어 시스템에서 코어별 부하 불균형 문제를 해결하는 방법이 아닌 것은?",
        options: [
            "푸시 마이그레이션 기법",
            "풀 마이그레이션 기법",
            "부하 균등화 기법",
            "라운드 로빈 스케줄링"
        ],
        answer: 4
    },
    {
        question: "10. Windows 작업 관리자에서 프로세스에게 코어 친화성을 지정할 때의 특징은?",
        options: [
            "각 스레드마다 개별적으로 코어를 지정해야 한다",
            "프로세스의 모든 스레드가 지정된 CPU 코어로 스케줄된다",
            "코어 친화성 설정은 시스템 재시작 후에만 적용된다",
            "관리자 권한이 필요하다"
        ],
        answer: 2
    },
    {
        question: "11. Windows 작업 관리자에서 'CPU'라고 표시되는 것은 실제로 무엇을 의미하는가?",
        options: [
            "물리적 CPU",
            "코어",
            "스레드",
            "캐시"
        ],
        answer: 2
    },
    {
        question: "12. 멀티코어 시스템에서 싱글 코어 CPU 스케줄링을 그대로 사용할 때 발생하는 주요 문제점은?",
        options: [
            "컨텍스트 스위칭 후 오버헤드 문제만 발생",
            "코어별 부하 불균형 문제만 발생",
            "컨텍스트 스위칭 후 오버헤드 문제와 코어별 부하 불균형 문제 모두 발생",
            "스레드 생성 비용이 증가하는 문제만 발생"
        ],
        answer: 3
    },
    {
        question: "13. Chrome 프로세스를 코어 1에 할당했을 때, 실제로 영향을 받는 것은?",
        options: [
            "Chrome 프로세스의 주 스레드만",
            "Chrome 프로세스의 UI 스레드만",
            "Chrome 프로세스의 모든 스레드",
            "Chrome 프로세스와 관련된 다른 프로세스들"
        ],
        answer: 3
    },
    {
        question: "14. 코어 당 스레드 큐를 사용하는 이유는?",
        options: [
            "메모리 사용량을 줄이기 위해",
            "스레드 생성 비용을 줄이기 위해",
            "CPU 친화성을 효과적으로 구현하기 위해",
            "전력 소비를 줄이기 위해"
        ],
        answer: 3
    },
    {
        question: "15. 부하 균등화 기법을 사용하는 주된 목적은?",
        options: [
            "전체 시스템의 전력 소비를 줄이기 위해",
            "모든 코어를 균등하게 활용하여 시스템 성능을 최적화하기 위해",
            "메모리 사용량을 줄이기 위해",
            "스레드 간 통신 비용을 줄이기 위해"
        ],
        answer: 2
    },
    {
        question: "16. 멀티코어 환경에서 캐시 미스가 발생하는 주된 이유는?",
        options: [
            "메모리 부족으로 인한 것",
            "스레드가 이전에 실행된 적이 없는 코어로 이동했을 때",
            "너무 많은 스레드가 동시에 실행되기 때문",
            "운영체제의 버그로 인한 것"
        ],
        answer: 2
    },
    {
        question: "17. 멀티코어 시스템의 스케줄링에서 'affinity'의 핵심 아이디어는?",
        options: [
            "스레드를 여러 코어에 골고루 분산시키는 것",
            "스레드를 한 번 실행된 코어에 계속 머물게 하는 것",
            "가장 빠른 코어에만 스레드를 할당하는 것",
            "스레드의 우선순위에 따라 코어를 할당하는 것"
        ],
        answer: 2
    },
    {
        question: "18. Push Migration과 Pull Migration 기법의 공통점은?",
        options: [
            "둘 다 스레드가 자발적으로 이동하는 방식이다",
            "둘 다 부하 균등화를 위한 기법이다",
            "둘 다 캐시 성능을 최적화하는 기법이다",
            "둘 다 전력 소비를 줄이는 기법이다"
        ],
        answer: 2
    },
    {
        question: "19. 멀티코어 환경에서 컨텍스트 스위칭 후 성능이 저하되는 주된 이유는?",
        options: [
            "더 많은 메모리가 필요하기 때문",
            "더 많은 CPU 명령어가 필요하기 때문",
            "새로운 스레드의 코드와 데이터가 캐시에 채워지는 시간이 필요하기 때문",
            "스레드 간 통신이 더 복잡해지기 때문"
        ],
        answer: 3
    },
    {
        question: "20. 멀티코어 시스템에서 스레드를 무작위로 할당할 때의 문제점은?",
        options: [
            "캐시 효율성이 떨어진다",
            "코어마다 처리할 스레드 수의 불균형이 발생한다",
            "전력 소비가 증가한다",
            "위의 모든 것이 문제점이다"
        ],
        answer: 2
    }
];
