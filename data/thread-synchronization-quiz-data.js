let quizData = [
    {
        question: "1. 스레드 동기화가 필요한 경우는 언제인가?",
        options: [
            "두 스레드가 동시에 공유 데이터를 읽을 때",
            "한 스레드는 읽고 한 스레드는 쓸 때",
            "두 스레드가 동시에 공유 데이터를 쓸 때",
            "모든 경우에 필요하다"
        ],
        answer: 3
    },
    {
        question: "2. 스레드 동기화(thread synchronization)의 정의는?",
        options: [
            "여러 스레드가 동시에 실행되도록 하는 기법",
            "공유데이터에 대한 다수의 스레드가 동시에 접근할 때 공유데이터가 훼손되지 않게 하는 기법",
            "스레드 간의 통신을 원활하게 하는 기법",
            "스레드의 실행 순서를 정하는 기법"
        ],
        answer: 2
    },
    {
        question: "3. 은행 회비 계좌 예시에서 2명이 동시에 100만원씩 입금했는데 잔액이 200만원이 된 이유는?",
        options: [
            "계산 오류가 발생했기 때문",
            "두 스레드가 동시에 공유데이터에 접근하여 공유데이터가 훼손되었기 때문",
            "메모리 부족으로 인한 오류",
            "네트워크 지연으로 인한 문제"
        ],
        answer: 2
    },
    {
        question: "4. 임계구역(critical section)이란?",
        options: [
            "메모리의 특정 영역",
            "공유 데이터에 접근하는 프로그램 코드들",
            "스레드가 생성되는 영역",
            "에러가 발생할 가능성이 높은 코드"
        ],
        answer: 2
    },
    {
        question: "5. 상호배제(mutual exclusion)의 정의는?",
        options: [
            "여러 스레드가 동시에 실행되지 않도록 하는 기술",
            "임계구역을 오직 한 스레드만 배타적, 독점적으로 사용하도록 하는 기술",
            "스레드 간의 데이터 공유를 금지하는 기술",
            "스레드의 우선순위를 정하는 기술"
        ],
        answer: 2
    },
    {
        question: "6. 'sum = sum + 10;' 연산이 어셈블리 코드로 변환될 때 몇 개의 명령으로 구성되는가?",
        options: [
            "1개",
            "2개",
            "3개",
            "4개"
        ],
        answer: 3
    },
    {
        question: "7. 탐구 6-1의 C 프로그램에서 두 스레드가 각각 1,000,000번씩 sum에 10을 더했을 때 예상 결과는?",
        options: [
            "10,000,000",
            "20,000,000",
            "실행할 때마다 다른 값",
            "1,000,000"
        ],
        answer: 2
    },
    {
        question: "8. 탐구 6-1 프로그램이 올바르게 작동하지 않는 이유는?",
        options: [
            "메모리가 부족해서",
            "'sum = sum + 10'이 임계구역인데 동기화 기능이 없어서",
            "스레드가 너무 많아서",
            "컴파일러 오류 때문에"
        ],
        answer: 2
    },
    {
        question: "9. 공유 데이터 접근 문제를 해결하기 위한 방법은?",
        options: [
            "스레드 개수를 줄인다",
            "한 스레드가 공유 데이터 사용을 마칠 때까지 다른 스레드가 접근하지 못하도록 제어한다",
            "더 빠른 CPU를 사용한다",
            "메모리를 늘린다"
        ],
        answer: 2
    },
    {
        question: "10. 멀티스레드의 경쟁 상황(race condition)은 얼마나 자주 발생하는가?",
        options: [
            "거의 발생하지 않는다",
            "가끔 발생한다",
            "매우 자주 발생한다",
            "특정 상황에서만 발생한다"
        ],
        answer: 3
    },
    {
        question: "11. 커널 코드에서 경쟁 상황이 자주 발생하는 이유는?",
        options: [
            "커널 코드가 복잡해서",
            "커널에 공유 데이터가 많기 때문",
            "커널이 느려서",
            "커널이 오래되어서"
        ],
        answer: 2
    },
    {
        question: "12. 다중 코어 환경에서 경쟁 상황이 더 주의해야 하는 이유는?",
        options: [
            "코어가 많아서 더 복잡해진다",
            "코어 간 동기화가 어렵다",
            "여러 코어에서 동시에 공유 데이터에 접근할 가능성이 높아진다",
            "코어별로 다른 운영체제를 사용한다"
        ],
        answer: 3
    },
    {
        question: "13. 상호배제를 포함하는 프로그램의 구조에서 임계구역 진입 코드의 역할은?",
        options: [
            "공유 데이터를 초기화한다",
            "현재 임계구역을 사용 중인 스레드가 있는지 검사하고 대기하거나 진입을 허용한다",
            "스레드의 우선순위를 변경한다",
            "메모리를 할당한다"
        ],
        answer: 2
    },
    {
        question: "14. 임계구역 진출 코드의 목적은?",
        options: [
            "스레드를 종료한다",
            "대기중인 스레드가 임계구역에 진입할 수 있도록 조치를 해제한다",
            "공유 데이터를 백업한다",
            "메모리를 해제한다"
        ],
        answer: 2
    },
    {
        question: "15. 두 스레드가 공유 데이터를 읽는 경우 발생하는 문제는?",
        options: [
            "공유 데이터가 훼손된다",
            "시스템이 충돌한다",
            "문제없다",
            "성능이 저하된다"
        ],
        answer: 3
    },
    {
        question: "16. 한 스레드는 쓰고 한 스레드는 읽는 경우의 특징은?",
        options: [
            "반드시 공유데이터가 훼손된다",
            "읽고 쓰는 순서에 따라 읽는 값이 달라질 수 있지만 공유데이터의 훼손은 없다",
            "항상 같은 값을 읽는다",
            "스레드 동기화가 필요없다"
        ],
        answer: 2
    },
    {
        question: "17. 공유 집계판 사례에서 MT가는 날 문제는 무엇에 대한 비유인가?",
        options: [
            "스레드 생성 과정",
            "메모리 관리 문제",
            "스레드 동기화의 필요성",
            "CPU 스케줄링 문제"
        ],
        answer: 3
    },
    {
        question: "18. 탐구 6-1에서 worker 함수는 몇 번의 반복을 수행하는가?",
        options: [
            "10,000번",
            "100,000번",
            "1,000,000번",
            "10,000,000번"
        ],
        answer: 3
    },
    {
        question: "19. 탐구 6-1에서 사용되는 스레드 라이브러리는?",
        options: [
            "Windows Thread",
            "POSIX pthread",
            "Java Thread",
            "C++ Thread"
        ],
        answer: 2
    },
    {
        question: "20. 스레드 동기화 문제의 근본적인 해결책은?",
        options: [
            "더 빠른 하드웨어 사용",
            "스레드 수 제한",
            "상호배제를 통해 한 시점에 하나의 스레드만 공유 데이터에 접근하도록 제어",
            "공유 데이터 사용 금지"
        ],
        answer: 3
    },
    {
        question: "21. 탐구 6-1의 어셈블리 코드에서 첫 번째 명령 'mov ax, sum'의 역할은?",
        options: [
            "sum 변수의 주소를 ax에 저장",
            "sum 변수 값을 읽어 ax 레지스터에 저장",
            "ax 레지스터의 값을 sum에 저장",
            "sum 변수를 초기화"
        ],
        answer: 2
    },
    {
        question: "22. 탐구 6-1에서 실행 결과가 각각 다른 이유는?",
        options: [
            "컴파일러의 차이",
            "시스템 성능의 차이",
            "두 스레드 간의 경쟁 상황이 실행할 때마다 다르게 발생하기 때문",
            "메모리 상태의 차이"
        ],
        answer: 3
    },
    {
        question: "23. 공유 집계판 문제에서 학생이 짐을 옮기는 행위는 무엇을 모델링한 것인가?",
        options: [
            "스레드 생성",
            "스레드의 작업 수행",
            "메모리 할당",
            "CPU 스케줄링"
        ],
        answer: 2
    },
    {
        question: "24. 탐구 6-1에서 두 스레드의 이름으로 사용된 것은?",
        options: [
            "Thread1, Thread2",
            "황기태, 이찬수",
            "Producer, Consumer",
            "Worker1, Worker2"
        ],
        answer: 2
    },
    {
        question: "25. 스레드 동기화 문제가 발생하는 근본 원인은?",
        options: [
            "CPU의 속도가 빠르기 때문",
            "높은 레벨 언어를 사용하기 때문",
            "고급 연산이 여러 개의 기계어 명령으로 번역되고 그 사이에 컨텍스트 스위칭이 발생할 수 있기 때문",
            "메모리 접근 속도가 느리기 때문"
        ],
        answer: 3
    }
];
