let quizData = [
    {
        question: "1. 멀티스레드 동기화란 무엇인가?",
        options: [
            "여러 스레드를 동시에 실행하는 기법",
            "상호배제 기반위에 자원을 사용하려는 여러 스레드들이 자원을 원활히 공유하도록 하는 기법",
            "스레드 간의 통신을 원활하게 하는 기법",
            "스레드의 실행 순서를 정하는 기법"
        ],
        answer: 2
    },
    {
        question: "2. 멀티스레드 동기화에서 locks 방식에 해당하는 것은?",
        options: [
            "뮤텍스(mutex), 스핀락(spinlock)",
            "세마포(semaphore)",
            "컨디션 변수(condition variable)",
            "메시지 큐(message queue)"
        ],
        answer: 1
    },
    {
        question: "3. wait-signal 방식의 대표적인 예는?",
        options: [
            "뮤텍스",
            "스핀락",
            "세마포(semaphore)",
            "임계구역"
        ],
        answer: 3
    },
    {
        question: "4. 뮤텍스 기법에서 락 변수의 값은?",
        options: [
            "0 또는 양의 정수",
            "true 또는 false",
            "음수 또는 양수",
            "-1 또는 1"
        ],
        answer: 2
    },
    {
        question: "5. 뮤텍스에서 락이 잠긴 상태일 때 스레드는 어떻게 처리되는가?",
        options: [
            "무한 루프를 돌며 대기",
            "블록 상태로 만들고 대기 큐에 삽입",
            "다른 작업을 수행",
            "에러 발생"
        ],
        answer: 2
    },
    {
        question: "6. 뮤텍스가 적합한 상황은?",
        options: [
            "임계구역의 실행 시간이 긴 경우",
            "임계구역의 실행 시간이 짧은 경우",
            "단일 CPU 시스템에서만",
            "메모리 사용량이 적은 경우"
        ],
        answer: 1
    },
    {
        question: "7. 스핀락(spinlock) 기법의 특징은?",
        options: [
            "sleep-waiting lock 기법",
            "busy-waiting lock 기법",
            "대기 큐를 사용",
            "뮤텍스와 동일한 기법"
        ],
        answer: 2
    },
    {
        question: "8. 스핀락에서 락이 잠긴 상태일 때 스레드는 어떻게 행동하는가?",
        options: [
            "대기 큐에서 잠을 잠",
            "계속 락 변수를 검사하며 대기",
            "다른 작업을 수행",
            "에러를 발생시킴"
        ],
        answer: 2
    },
    {
        question: "9. 스핀락이 단일 CPU 시스템에서 비효율적인 이유는?",
        options: [
            "메모리를 많이 사용해서",
            "의미 없는 CPU 시간 낭비 때문",
            "컨텍스트 스위칭이 없어서",
            "락이 해제되지 않아서"
        ],
        answer: 2
    },
    {
        question: "10. 스핀락이 적합한 환경은?",
        options: [
            "단일 CPU 시스템",
            "임계구역이 큰 응용프로그램",
            "멀티 코어 시스템에서 임계구역이 짧은 경우",
            "메모리가 부족한 시스템"
        ],
        answer: 3
    },
    {
        question: "11. 뮤텍스와 스핀락의 주요 차이점은?",
        options: [
            "뮤텍스는 선점형, 스핀락은 비선점형",
            "뮤텍스는 sleep-waiting, 스핀락은 busy-waiting",
            "뮤텍스는 하드웨어적, 스핀락은 소프트웨어적",
            "뮤텍스는 빠르고, 스핀락은 느림"
        ],
        answer: 2
    },
    {
        question: "12. 스핀락이 커널 코드에서 주로 사용되는 이유는?",
        options: [
            "커널 코드는 빠르게 실행되어야 하고 인터럽트 서비스 루틴 내에서 잠잘 수 없기 때문",
            "커널에서는 뮤텍스를 사용할 수 없어서",
            "커널 코드가 단순해서",
            "메모리를 절약하기 위해"
        ],
        answer: 1
    },
    {
        question: "13. 탐구 6-2의 뮤텍스 예제에서 worker() 함수를 수정한 버전의 특징은?",
        options: [
            "더 빠른 실행",
            "대기 상태를 비교할 수 있음",
            "한 스레드가 모든 작업을 완료한 후 다른 스레드가 실행",
            "더 안전한 동기화"
        ],
        answer: 3
    },
    {
        question: "14. 탐구 6-3의 스핀락 예제에서 pthread_spin_init의 두 번째 인자 의미는?",
        options: [
            "락을 초기화하는 값",
            "타임아웃 시간",
            "한 프로세스에 속한 스레드만이 공유하는 변수로 선언",
            "스핀락의 우선순위"
        ],
        answer: 3
    },
    {
        question: "15. 스핀락에서 기아가 발생할 수 있는 상황은?",
        options: [
            "뮤텍스를 함께 사용할 때",
            "무한 경쟁 방식으로 인해 락을 계속 얻지 못할 때",
            "메모리가 부족할 때",
            "CPU가 하나일 때"
        ],
        answer: 2
    },
    {
        question: "16. 세마포(semaphore)의 주요 목적은?",
        options: [
            "한 개의 공유 자원을 한 번에 하나의 스레드만 사용하도록 함",
            "n개의 공유 자원을 다수 스레드가 공유하여 사용하도록 돕는 자원 관리",
            "스레드 간의 메시지 전달",
            "메모리 사용량 최적화"
        ],
        answer: 2
    },
    {
        question: "17. 세마포의 counter 변수 초기값은?",
        options: [
            "0",
            "1",
            "n (자원의 개수)",
            "-1"
        ],
        answer: 3
    },
    {
        question: "18. 세마포에서 P 연산이란?",
        options: [
            "자원 반환 시 실행하는 연산",
            "자원 요청 시 실행하는 연산 (wait 연산)",
            "세마포 초기화 연산",
            "세마포 종료 연산"
        ],
        answer: 2
    },
    {
        question: "19. 세마포에서 V 연산이란?",
        options: [
            "자원 요청 시 실행하는 연산",
            "자원 반환 시 실행하는 연산 (signal 연산)",
            "세마포 검증 연산",
            "세마포 값 설정 연산"
        ],
        answer: 2
    },
    {
        question: "20. sleep-wait 세마포에서 P 연산의 특징은?",
        options: [
            "counter 증가, 스레드 깨우기",
            "counter 감소, 대기 큐에서 잠자기",
            "무한 루프로 대기",
            "다른 작업 수행"
        ],
        answer: 2
    },
    {
        question: "21. busy-wait 세마포에서 P 연산의 특징은?",
        options: [
            "대기 큐에서 잠자기",
            "사용 가능 자원이 생길 때까지 무한 루프 후 자원이 생기면 counter 감소",
            "즉시 에러 반환",
            "다른 작업 수행"
        ],
        answer: 2
    },
    {
        question: "22. sem_trywait() 함수의 특징은?",
        options: [
            "blocking call로 가용 자원이 없으면 대기",
            "non-blocking call로 가용 자원이 없으면 -1 리턴",
            "세마포를 초기화하는 함수",
            "세마포를 종료하는 함수"
        ],
        answer: 2
    },
    {
        question: "23. 탐구 6-4의 세마포 예제에서 MAX_COUNTER 값은?",
        options: [
            "1",
            "2",
            "3",
            "5"
        ],
        answer: 3
    },
    {
        question: "24. 카운터 세마포와 이진 세마포의 차이점은?",
        options: [
            "카운터 세마포는 여러 개, 이진 세마포는 한 개의 자원 관리",
            "카운터 세마포는 빠르고, 이진 세마포는 느림",
            "카운터 세마포는 하드웨어적, 이진 세마포는 소프트웨어적",
            "기능상 차이가 없음"
        ],
        answer: 1
    },
    {
        question: "25. 이진 세마포의 초기값은?",
        options: [
            "0",
            "1",
            "n",
            "-1"
        ],
        answer: 2
    },
    {
        question: "26. 우선순위 역전(priority inversion)이란?",
        options: [
            "높은 우선순위 스레드가 먼저 실행되는 현상",
            "스레드 동기화로 인해 높은 순위의 스레드가 낮은 스레드보다 늦게 스케줄링되는 현상",
            "우선순위가 자동으로 변경되는 현상",
            "낮은 순위 스레드가 CPU를 독점하는 현상"
        ],
        answer: 2
    },
    {
        question: "27. 우선순위 상속(priority inheritance) 해결책은?",
        options: [
            "낮은 순위 스레드의 우선순위를 요청한 높은 순위 스레드보다 높게 설정",
            "높은 순위 스레드의 우선순위를 낮춤",
            "모든 스레드의 우선순위를 동일하게 설정",
            "세마포 대신 뮤텍스 사용"
        ],
        answer: 1
    },
    {
        question: "28. 우선순위 올림(priority ceiling) 해결책은?",
        options: [
            "스레드가 종료될 때 우선순위 증가",
            "스레드가 공유 자원을 소유할 때 미리 정해진 높은 우선순위로 일시적 상승",
            "모든 스레드의 우선순위를 최고로 설정",
            "우선순위를 사용하지 않음"
        ],
        answer: 2
    },
    {
        question: "29. 탐구 6-2의 뮤텍스 예제에서 lock과 unlock 사이에 놓인 코드는?",
        options: [
            "entry 코드",
            "exit 코드",
            "임계구역 코드",
            "초기화 코드"
        ],
        answer: 3
    },
    {
        question: "30. POSIX에서 스핀락 변수 선언 방법은?",
        options: [
            "pthread_mutex_t lock;",
            "pthread_spinlock_t lock;",
            "sem_t lock;",
            "spin_t lock;"
        ],
        answer: 2
    }
];
